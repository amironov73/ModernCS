### System.Threading.Timer

В .NET имеется несколько разных таймеров, некоторые из них используются очень широко (таймеры из WinForms), а другие годами остаются «в тени». Это несправедливо.

Таймеры из пространства имён `System.Threading` представляют собой замечательный механизм организации периодического исполнения кода, не завязанного на пользовательский интерфейс (например, в сетевых сервисах).

```csharp
public delegate void TimerCallback
    (
        object state // объект состояния
    );
 
public class Timer
{
  // Конструктор
  public Timer
    (
        TimerCallback callback, // метод для вызова
        object state, // состояние
        int dueTime, // начальная задержка, мс
        int period // период, мс
    );
 
  // Изменение периодичности
  public bool Change
    (
        int dueTime,
        int period
    );
 
  // Отключение
  public void Dispose();
 
  // Отключение с оповещением
  public bool Dispose
    (
        WaitHandle notifyObject
    );
}
```

Реализация таймеров довольно экономичная: создаётся один (на домен приложения) ядерный объект «таймер», один список `System.Threading.TimerQueue`, в который складываются пользовательские таймеры, и один поток, который вычисляет сколько надо ждать до ближайшего срабатывания одного из таймеров, устанавливает соответствующие параметры объекту ядра «таймер» и собственно ждёт. Связанный с таймером делегат запускается в потоке пула (ThreadPool). Если потоки пула оказались все заняты запросами и в итоге закончились, таймер будет ждать в очереди. Callback-метод должен быть реентерантным и не привязанным к UI-потоку (т. к. будет запущен в потоке пула, а не в UI-потоке).

Данный тип таймера не гарантирует точного отсчёта интервалов, это не мультимедийный таймер, он не годится, например, для плавного воспроизведения звука.

Предупреждение: необходимо сохранять ссылку на объект таймера всё время, пока он нужен, иначе он может быть случайно собран GC, отчего просто молча перестанет работать.
