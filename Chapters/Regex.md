### Как правильно использовать регулярные выражения в .NET

Краткий пересказ статьи [«Best Practices for Regular Expressions in the .NET Framework»](https://msdn.microsoft.com/en-us/library/gg578045(v=vs.110).aspx).

1. На примере довольно простого и популярного регулярного выражения «\^\[0-9A-Z\]([-.\w]\*[0-9A-Z])\*$» (проверяет псевдоним электронной почты) показано, что, хотя эта регулярка хорошо обрабатывает корректные входные строки, она очень неэффективна для почти корректных входных данных. Если почти подходящий адрес email содержит более 5 символов, время обработки удваивается для каждого дополнительного символа. Таким образом, почти правильная строка из 28 символов будет обрабатываться больше часа, а из 33 символов – около суток. Проблема в том, что регулярка ориентирована только на корректные входные данные.

2. При использовании статических методов вроде Regex.Match (string, string) используется внутренний кэш скомпилированного IL. По умолчанию кэш содержит 15 последних регулярок, его размер можно изменить с помощью статического свойства Regex.CacheSize.

3. Регулярки могут компилироваться в IL, а могут интерпретироваться. Первый вариант предпочтительнее для регулярок, которые должны отработать много раз. Скомпилированную регулярку можно сохранить в отдельную сборку с помощью метода Regex.CompileToAssembly.

4. Обычно регулярка двигается по входной строке от начала к концу. Однако, когда используются квантификаторы *, + или ?, могут происходить возвраты к ранее сохранённому состоянию. В неблагоприятных случаях каждый возврат может удваивать время обработки при каждом добавлении символа во входную строку. Так что, если не повезёт, регулярка может работать сутками.

Отключить поиск с возвратом можно с помощью языкового элемента (?>subexpression). Так, две регулярки: \b\p{Lu}\w*\b и \b\p{Lu}(?>\w*)\b полностью эквивалентны с точки зрения обнаружения в строке слов, начинающихся с прописной буквы, но вторая не вызывает проседания производительности.

Можно использовать утверждения просмотра вперёд или назад нулевой ширины. Такие утверждения являются «якорями», они не двигают указатель по входной строке, а просто проверяют, выполняются ли заданные условия.

| Элемент языка | Описание |
|---------------|----------|
| (?=subexpression) | Положительный просмотр вперед нулевой ширины. Поиск перед текущей позицией с целью проверить, совпадает ли параметр subexpression со входной строкой. |
| (?!subexpression) | Отрицательный просмотр вперед нулевой ширины. Поиск перед текущей позицией с целью проверить, что параметр subexpression не совпадает со входной строкой. |
| (?<=subexpression) | Положительный просмотр назад нулевой ширины. Поиск за текущей позицией с целью проверить, совпадает ли параметр subexpression со входной строкой. |
| (?&lt;!subexpression) | Отрицательный просмотр назад нулевой ширины. Поиск за текущей позицией с целью проверить, что параметр subexpression не совпадает со входной строкой. |

5. Рекомендуется использовать ограничение по времени работы регулярки.

6. Захват значений групп надо делать только в случае необходимости. Для этого применяют следующие методы (любой на выбор):

* языковой элемент (?:subexpression);
* параметр ExplicitCapture;
* языковой элемент (?n).

